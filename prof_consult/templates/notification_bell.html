<!-- templates/components/notification_bell.html -->

<style>
/* Notification Bell Styles */
.notification-bell {
    position: relative;
    margin-right: 15px;
}

.notification-bell .nav-link {
    position: relative;
    padding: 8px 12px;
}

.notification-badge {
    position: absolute;
    top: 0;
    right: 0;
    background-color: #dc3545;
    color: white;
    border-radius: 10px;
    padding: 2px 6px;
    font-size: 11px;
    font-weight: bold;
    min-width: 18px;
    text-align: center;
}

/* Mobile-only compact notification bell */
@media (max-width: 991.98px) {
    .notification-bell {
        margin-right: 0;
    }
    .notification-bell .nav-link {
        padding: 4px 6px;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    .notification-badge {
        top: -2px;
        right: -2px;
        padding: 1px 4px;
        font-size: 9px;
        min-width: 14px;
    }
}

.notification-dropdown {
    min-width: 320px;
    max-width: 400px;
    max-height: 400px;
    overflow-y: auto;
}

.notification-item {
    padding: 12px 16px;
    border-bottom: 1px solid #e9ecef;
    cursor: pointer;
    transition: background-color 0.2s;
}

.notification-item:hover {
    background-color: #f8f9fa;
}

.notification-item.unread {
    background-color: #e7f3ff;
}

.notification-item.unread:hover {
    background-color: #d0e8ff;
}

.notification-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 16px;
    border-bottom: 2px solid #dee2e6;
    font-weight: 600;
}

.notification-time {
    font-size: 12px;
    color: #6c757d;
    margin-top: 4px;
}

.notification-text {
    font-size: 14px;
    margin: 0;
}

.notification-empty {
    padding: 20px;
    text-align: center;
    color: #6c757d;
}

.mark-all-read {
    font-size: 12px;
    color: #2780e3;
    cursor: pointer;
    text-decoration: none;
}

.mark-all-read:hover {
    text-decoration: underline;
}

@keyframes bell-ring {
    0% { transform: rotate(0); }
    10% { transform: rotate(15deg); }
    20% { transform: rotate(-15deg); }
    30% { transform: rotate(10deg); }
    40% { transform: rotate(-10deg); }
    50% { transform: rotate(0); }
}

.notification-bell.has-new .bi-bell-fill {
    animation: bell-ring 1s ease-in-out;
}
</style>

<!-- Notification Bell Component -->
<li class="nav-item dropdown notification-bell" id="notificationBell">
    <a class="nav-link" href="#" id="notificationDropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
        <i class="bi bi-bell-fill" style="font-size: 1.2rem;"></i>
        <span class="notification-badge" id="notificationBadge" style="display: none;">0</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end notification-dropdown" aria-labelledby="notificationDropdown">
        <li class="notification-header">
            <span>Notifications</span>
            <a href="#" class="mark-all-read" id="markAllRead">Mark all as read</a>
        </li>
        <li>
            <div id="notificationsList">
                <div class="notification-empty">
                    <i class="bi bi-bell" style="font-size: 2rem; color: #dee2e6;"></i>
                    <p class="mt-2 mb-0">No new notifications</p>
                </div>
            </div>
        </li>
    </ul>
</li>

<script>
class NotificationSystem {
    constructor() {
        this.notifications = [];
        this.unreadCount = 0;
        this.pollInterval = 30000; // Poll every 30 seconds
        this.init();
    }

    init() {
        this.loadNotifications();
        this.startPolling();
        this.setupEventListeners();
    }

    setupEventListeners() {
        document.getElementById('markAllRead')?.addEventListener('click', (e) => {
            e.preventDefault();
            this.markAllAsRead();
        });
    }

    async loadNotifications() {
        try {
            // Replace with your actual API endpoint
            const response = await fetch('/api/notifications/', {
                headers: {
                    'X-Requested-With': 'XMLHttpRequest',
                }
            });
            
            if (response.ok) {
                const data = await response.json();
                this.notifications = data.notifications || [];
                this.unreadCount = data.unread_count || 0;
                this.render();
            }
        } catch (error) {
            console.error('Error loading notifications:', error);
            // Use demo data if API fails
            this.loadDemoNotifications();
        }
    }

    loadDemoNotifications() {
        // Demo notifications for testing
        this.notifications = [
            {
                id: 1,
                text: 'Your consultation with Dr. Smith has been confirmed',
                time: '5 minutes ago',
                read: false,
                url: '/consultations/1/'
            },
            {
                id: 2,
                text: 'New consultation request from John Doe',
                time: '1 hour ago',
                read: false,
                url: '/consultations/2/'
            },
            {
                id: 3,
                text: 'Your consultation is starting in 30 minutes',
                time: '2 hours ago',
                read: true,
                url: '/consultations/3/'
            }
        ];
        this.unreadCount = this.notifications.filter(n => !n.read).length;
        this.render();
    }

    render() {
        const badge = document.getElementById('notificationBadge');
        const list = document.getElementById('notificationsList');
        const bell = document.getElementById('notificationBell');

        // Update badge
        if (this.unreadCount > 0) {
            badge.textContent = this.unreadCount > 99 ? '99+' : this.unreadCount;
            badge.style.display = 'block';
            bell.classList.add('has-new');
        } else {
            badge.style.display = 'none';
            bell.classList.remove('has-new');
        }

        // Render notifications
        if (this.notifications.length === 0) {
            list.innerHTML = `
                <div class="notification-empty">
                    <i class="bi bi-bell" style="font-size: 2rem; color: #dee2e6;"></i>
                    <p class="mt-2 mb-0">No new notifications</p>
                </div>
            `;
        } else {
            list.innerHTML = this.notifications.map(notif => `
                <div class="notification-item ${notif.read ? '' : 'unread'}" 
                     data-id="${notif.id}" 
                     onclick="notificationSystem.handleNotificationClick(${notif.id}, '${notif.url}')">
                    <p class="notification-text mb-1">${notif.text}</p>
                    <div class="notification-time">${notif.time}</div>
                </div>
            `).join('');
        }
    }

    async handleNotificationClick(id, url) {
        await this.markAsRead(id);
        if (url) {
            window.location.href = url;
        }
    }

    async markAsRead(id) {
        try {
            await fetch(`/api/notifications/${id}/read/`, {
                method: 'POST',
                headers: {
                    'X-Requested-With': 'XMLHttpRequest',
                    'X-CSRFToken': this.getCsrfToken()
                }
            });
            
            const notif = this.notifications.find(n => n.id === id);
            if (notif && !notif.read) {
                notif.read = true;
                this.unreadCount--;
                this.render();
            }
        } catch (error) {
            console.error('Error marking notification as read:', error);
        }
    }

    async markAllAsRead() {
        try {
            await fetch('/api/notifications/mark-all-read/', {
                method: 'POST',
                headers: {
                    'X-Requested-With': 'XMLHttpRequest',
                    'X-CSRFToken': this.getCsrfToken()
                }
            });
            
            this.notifications.forEach(n => n.read = true);
            this.unreadCount = 0;
            this.render();
        } catch (error) {
            console.error('Error marking all as read:', error);
        }
    }

    startPolling() {
        setInterval(() => {
            this.loadNotifications();
        }, this.pollInterval);
    }

    getCsrfToken() {
        return document.querySelector('[name=csrfmiddlewaretoken]')?.value || '';
    }
}

// Initialize notification system when DOM is ready
if (typeof notificationSystem === 'undefined') {
    let notificationSystem;
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            notificationSystem = new NotificationSystem();
        });
    } else {
        notificationSystem = new NotificationSystem();
    }
}
</script>